( function () {
  "use strict";

  function checkIsValidLevelName( levelName ) {

    return ( /^[\w\-]+$/ ).test( levelName );
  }

  LAID.Level = function ( path, lson, parent ) {

    this.path = path;
    this.parent = parent; // parent Level
    // True if the Level is a Part Level,
    // false if the Level is a Many Level.
    this.isPart = undefined;
    // This is relevant if the Level is a Part.
    // If true it implies that this Part
    // has been generated by a Many Level.
    this.isManyDerived = undefined;

    // If the Level is a Many (i.e this.isPart is false)
    // then this.many will hold a reference to the corresponding
    // Many object.
    this.$part = undefined;
    // If the Level is a Many (i.e this.isPart is false)
    // then this.many will hold a reference to the corresponding
    // Many object.
    this.$many = undefined;
    // If the Level is derived from a Many Level
    // (i.e this.isManyDerived is true)
    // then this.derivedMany will hold
    // a reference to that Many object
    this.$derivedMany = undefined;

    this.$lson = lson;
    this.$attr2attrValue = {};


    this.recalculateDirtyAttrValueS = [];
    this.renderDirtyAttrValueS = [];

    this.$stateS = [];
    this.$stringHashedStates2_cachedAttr2val_ =  {};

    this.$whenEventType2fnMainHandler = {};




  };



  LAID.Level.prototype.init = function () {

    LAID.$path2level[ this.path ] = this;

    if ( !LAID.$isClogged ) {
      LAID.$newLevelS.push( this );
      if ( !LAID.$isSolvingNewLevels ) {
        LAID.$solveForNew();
      }

    } else {
      LAID.$cloggedLevelS.push( this );
    }

  };

  LAID.Level.prototype.addChildren = function ( name2lson ) {

    var childPath, childLevel;
    if ( name2lson !== undefined ) {
      for ( var name in name2lson ) {

        if ( !checkIsValidLevelName( name ) ) {
          throw ( "LAID Error: Invalid Level Name: " + name );
        }

        childPath = this.path + '/' + name;
        if ( LAID.$path2level[ childPath ] !== undefined ) {
          throw ( "LAID Error: Level already exists with path: " + childPath );
        }
        ( new LAID.Level( childPath, name2lson[ name ], this ) ).init();

      }
    }

  };



  /*
  * Return false if the level could not be inherited (due
  * to another level not being present or started as yet)
  * Else add the level's children to the tree and return true
  */
  LAID.Level.prototype.$inheritAndReproduce = function () {

    var lson, refS, i, len, ref, level, inheritedAndNormalizedLson;

    LAID.$normalize( lson, false );
    if ( this.$lson.inherits !== undefined ) { // does not contain anything to inherit from

      lson = { type: "none" };
      refS = this.$lson.inherits;
      for ( i = 0, len = refS.length; i < len; i++ ) {

        ref = refS[ i ];
        if ( typeof ref === "string" ) { // pathname reference

          level = ( new LAID.Path( ref ) ).resolve( this );
          if ( level === undefined || !level.$isStarted ) {

            return false;

          }
        }
      }
      for ( i = 0; i < len; i++ ) {

        ref = refS[ i ];
        if ( typeof ref === "string" ) { // pathname reference

          level = ( new LAID.Path( ref ) ).resolve( this );


          inheritedAndNormalizedLson = level.$lson;

        } else { // object reference

          inheritedAndNormalizedLson = LAID.$normalize( ref, true );

        }

        LAID.$inherit( lson, inheritedAndNormalizedLson, false, false );

      }

      LAID.$inherit( lson, this.$lson, false, false );
      this.$lson = lson;
    }



    if ( this.$lson.children !== undefined ) {
      this.addChildren( $lson.children );
    }

    return true;

  };



  function initAttrsObj( attrPrefix, key2val, attr2val ) {

    var key, val;

    for ( key in key2val ) {

      attr2val[ attrPrefix + key ] = key2val[ key ];

    }
  }

  function initAttrsArray( attrPrefix, elementS, attr2val ) {

    var i, len;

    for ( i = 0, len = attrS.length ; i < len; i++ ) {

      attr2val[ attrPrefix + i ] = elementS[ i ];

    }
  }

  /* Flatten the slson to attr2val dict */
  function convertSLSONtoAttr2Val( slson, attr2val, statePrefix, isRootState ) {

    var prop,
    transitionAttr, transitionDirective,
    transitionAttrPrefix,
    eventType, fnCallbackS,
    prop2val = slson.props,
    eventType2fnCallbackS = slson.when,
    transitionAttr2directive = slson.transition,
    i, len;


    initAttrsObj( statePrefix, slson.props, attr2val );

    for ( transitionAttr in transitionAttr2directive ) {
      transitionDirective = transition[ transitionAttr ];
      transitionAttrPrefix = statePrefix + "transition." + transitionAttr + ".";
      if ( transitionDirective.type !== undefined ) {
        attr2val[ transitionAttrPrefix + "type" ] = transitionDirective.type;
      }
      if ( transitionDirective.duration !== undefined ) {
        attr2val[ transitionAttrPrefix + "duration" ] = transitionDirective.duration;
      }
      if ( transitionDirective.delay !== undefined ) {
        attr2val[ transitionAttrPrefix + "delay" ] = transitionDirective.delay;
      }
      if ( transitionDirective.done !== undefined ) {
        attr2val[ transitionAttrPrefix + "done" ] = transitionDirective.done;
      }
      if ( transitionDirective.args !== undefined ) {
        initAttrsObj( transitionAttrPrefix, transitionDirective.args, attr2val );
      }
    }

    for ( eventType in eventType2fnCallbackS ) {
      fnCallbackS = eventType2fnCallbackS[ eventType ];
      initAttrsArray( statePrefix + "when." + eventType, fnCallbackS, attr2val );
    }

    if ( slson.$$num !== undefined ) {
      initAttrsObj( statePrefix + "$$num.", slson.$$num, attr2val );
    }

    if ( slson.$$max !== undefined ) {
      initAttrsObj( statePrefix + "$$max.", slson.$$max, attr2val );
    }

    if ( slson.$$keys !== undefined ) {
      initAttrsObj( statePrefix + "$$keys.", slson.$$keys, attr2val );
    }



    if ( !isRootState ) {
      attr2val[ statePrefix + "onlyif" ] = slson.onlyif;
      attr2val[ statePrefix + "install" ] = slson.install;
      attr2val[ statePrefix + "uninstall" ] = slson.uninstall;
    }
  }

  LAID.Level.prototype.$initAllAttrs = function () {

    this.$initNonStateProjectedAttrs();
    this.$updateStates();

  };

  LAID.Level.prototype.$initNonStateProjectedAttrs = function () {

    var i, key, val, stateName, state,

    states = this.$lson.states, when = this.$lson.when,
    transition = this.$lson.transition,
    attr2val = {};



    initAttrsObj( "data.", this.$lson.data, attr2val );

    convertSLSONtoAttr2Val( this.$lson, attr2val, "root.", true );


    for ( stateName in states ) {
      convertSLSONtoAttr2Val( states[ stateName ] , attr2val, stateName + ".", false );
    }

    this.$commitAttr2Val( attr2val );



  };

  LSON.prototype.$commitAttr2Val = function ( attr2val ) {

    var attr;
    for ( attr in attr2val ) {
      val = attr2val[ attr ];
      attrValue = this.attr2attrValue[ attr ];
      if ( ( attrValue === undefined ) ) {
        attrValue = this.attr2attrValue[ attr ] = new AttrValue( this, attr );
      }
      attrValue.update( val );

    }
  };

  /*
  * Solve by recalculating each attr within the
  * level which requires recalculation
  * Return 1 if all attributes were solved
  * Return 2 if some attributes were solved
  * Return 3 if no attributes were solved
  */
  LAID.prototype.$solveForRecalculation = function () {

    var i, len,
    isSolveProgressed,
    isSolvedProgressedOnce = false,
    recalculateDirtyAttrValueS = this.$recalculateDirtyAttrValueS;


    do {
      isSolveProgressed = false;
      for ( i = 0, len = recalculateDirtyAttrValueS.length; i < len; i++ ) {
        isSolveProgressed = recalculateDirtyAttrValueS[ i ].recalculate() || true;
        if ( isSolveProgressed ) {
          isSolvedProgressedOnce = true;
          this.$removeRecalculateDirtyAttrValue( recalculateDirtyAttrValueS[ i ] );
          i--;
        }
      }

      // The reason we will not use `len` to check the length below is
      // that more recalculate dirty levels could have been added during
      // the loop
    } while ( ( recalculateDirtyLevelS.length !== 0 ) && isSolveProgressed );


    return recalculateDirtyLevelS.length === 0 ? 1 : ( isSolveProgressedOnce ? 2 : 3 );

  };

  /*
  Undefine all current attributes which are influencable
  by states: props, transition, when, $$num, $$keys, $$max
  */
  LAID.Level.protoype.$undefineStateProjectedAttrs = function() {

    var attr;
    for ( attr in this.attr2attrValue ) {
      if ( this.attr2attrValue[ attr ].isStateProjectedAttr ) {
        this.attr2attrValue[ attr ].update( undefined );
      }
    }
  };





  /* Return the attr2value generated
  by the current states */
  LAID.Level.prototype.getStateAttr2val = function () {

    if ( this.isManyDerived ) {
      // TODO: get from Many object
    } else {
      var stringHashedStates = this.states.sort().join("&");
      if ( this.stringHashedStates2_cachedAttr2val_[ stringHashedStates ] === undefined ) {
        this.stringHashedStates2_cachedAttr2val_[ stringHashedStates ] =
        convertSLSONtoAttr2Val( this.generateSLSON(), {}, "", true );
      }
      return this.stringHashedStates2_cachedAttr2val_[ stringHashedStates ];
    }

  };


  /*
  *  From the current states generate the
  *  correspinding SLSON (state projected lson)
  *  Requirement: the order of states must be sorted
  */
  LAID.Level.prototype.generateSLSON =  function () {

    this.$stateS.sort();

    var slson = {}, attr2val;

    LSON.$inherit( slson, this.$lson, true, true );
    for ( var i = 0, len = this.$stateS.length; i < len; i++ ) {
      LSON.$inherit( slson, this.$lson.states[ this.$stateS[ i ] ] , true, true );
    }

    return slson;

  };




  LAID.Level.protoype.$updateStates = function () {

    var
    attr2val = this.getStateAttr2val(),
    attr, val,
    attrValue,
    i, len;

    this.undefineStateProjectedAttrs();

    this.$commitAttr2Val( attr2val );

    // TODO: fix this outdated comment below
    //
    // state projected attributes are those attributes which
    // can be (key-)value modified by a state. This essentially
    // includes keys within "props", "when", and "transition".
    //
    // Get the entire list of state projected attributes with
    // the motive of removing (splicing) those attributes which
    // have been modified by the state. Ideally the list should
    // be empty at the end of

    // Algorithm
    //
    // allATTRS = filter(curATTRS)
    // for ATTR in (stateProjected) newATTRS
    //   dirty ATTR (=new value)
    //   remove ATTR from allATTRS
    // for ATTR in allATTRS
    //   dirty ATTR (=undefined)
    //



  };



  LAID.Level.prototype.$getAttrValue = function ( attr ) {

    return this.$attr2attrValue[ attr ];

  };


  LAID.Level.prototype.$addRecalculateDirtyAttrValue = function ( attrValue ) {

    LAID.$arrayUtils.pushUnique( this.$recalculateDirtyAttrValueS, attrValue );
    LAID.$arrayUtils.pushUnique( LAID.$recalculateDirtyLevelS, this );

  };

  LAID.Level.prototype.$addRenderDirtyAttrValue = function ( attrValue ) {

    LAID.$arrayUtils.pushUnique( this.$renderDirtyAttrValueS, attrValue );
    LAID.$arrayUtils.pushUnique( LAID.$renderDirtyLevelS, this );

  };

  LAID.Level.prototype.$removeRecalculateDirtyAttrValue = function ( attrValue ) {

    LAID.$arrayUtils.remove( this.$recalculateDirtyAttrValueS, attrValue );

  };

  LAID.Level.prototype.$removeRenderDirtyAttrValue = function ( attrValue ) {

    LAID.$arrayUtils.remove( this.$renderDirtyAttrValueS, attrValue );

  };

  LAID.Level.prototype.$updateWhenEventType = function ( eventType ) {

    var
    numFnHandlersForEventType = this.attr2attrValue[ "$$num." + eventType ],
    fnMainHandler,
    thisLevel = this;



    if ( this.$whenEventType2fnMainHandler[ eventType ] !== undefined ) {
      LAID.$eventUtils.remove( this.$part.node, eventType, prevWrapperEventHandlerS[ i ] );
    }


    if ( numFnHandlers !== 0 ) {
      fnMainHandler = function () {
        var i, len, attrValueForFnHandler;
        for ( i = 0; i < numFnHandlersForEventType; i++ ) {
          attrValueForFnHandler = thisLevel.attr2attrValue[ "when." + eventType + ( i + 1 ) ];
          if ( attrValueForFnHandler !== undefined ) {
            attrValueForFnHandler.calcValue.call( thisLevel );
          }
        }
      };
      LAID.$eventUtils.add( this.$part.node, eventType, fnMainHandler );
      this.$whenEventType2fnMainHandler[ eventType ] = fnMainHandler;

    } else {
      this.$whenEventType2fnMainHandler[ eventType ] = undefined;

    }
  };

  LAID.Level.prototype.$updateTransitionAttr = function ( transitionAttr ) {

    var affectedAttrS = [];
    if ( transitionAttr === "position" ) {
      affectedAttrS.concat([ "left", "top", "shiftX", "shiftY", "z",
      "scaleX", "scaleY",
      "rotateX", "rotateY", "rotateZ",
      "skewX", "skewY"
       ]);

    }

  };



  /*
  * For attrs which are of type state ( i.e state.<name> )
  * Return the name component.
  * Else return the empty string.
  */
  function getStateNameOfAttrState ( attr ) {

    return attr.startsWith( "state." ) ?
    attr.slice( 6 ) : "";

  }

  /*
  * For attrs which are of type when ( i.e state.<eventType><eventNum> )
  * Return the event type component.
  * Else return the empty string.
  */
  function getWhenEventTypeOfAttrWhen ( attr ) {

    return attr.startsWith( "when." ) ?
    attr.slice( 5, attr.length - 1 ) : "";

  }









  function checkIsStateProjectedAttr( attr ) {
    var i = attr.indexOf( "." );
    if ( i === -1 ) {
      return true;
    } else {
      var prefix = attr.slice( 0, i );
      return ( ( [ "when", "transition", "$$num", "$$max", "$$keys" ] ).indexOf( prefix ) !== -1 );
    }
  }

  function AttrValue ( attr, level ) {

    // undefined initializations:
    // (1) performance (http://jsperf.com/objects-with-undefined-initialized-properties/2)
    // (2) readability

    this.level = level;
    this.value = undefined;
    this.valueUsedForLastRecalculation = undefined;
    this.isTaken = undefined;
    this.attr = attr;
    this.isStateProjectedAttr = checkIsStateProjectedAttr( attr );

    this.calcValue = undefined;
    this.transitionCalcValue = undefined;

    this.transition = undefined;

    this.takerAttrValueS = [];

  }

  /* TODO: update this doc below along with its slash-asterisk
  formatting

  Returns true if the value is different,
  false otherwise */
  AttrValue.prototype.update = function ( value ) {

    this.value = value;

    if ( value !== this.valueUsedForLastRecalculation ) {

      if ( this.value instanceof LAID.Take ) {
        this.takeNot();
      }

      this.value = value;
      this.isTaken = false;
      this.requestRecalculation();

      return true;

    }

  };

  /*
  * Request the level corresponding to the given AttrValue
  * to recalculate this AttrValue.
  */
  AttrValue.prototype.requestRecalculation = function () {
    this.level.$addRecalculateDirtyAttrValue( this );
  };


  /*
  * TODO: update this doc below
  *
  * Recalculate the value of the attr value.
  * Propagate the change across the LOM (LAID object model)
  * if the change in value produces a change.
  * For constraint (take) based attributes, recalculate the
  * value, for non constraint based use the `value` parameter
  * as the change.
  * Return true if calculation successful, false if
  * a circular reference rendered it unsuccessful
  */
  AttrValue.prototype.recalculate = function () {

    var
    isDirty = false,
    reCalc,
    i, len;

    if ( this.value instanceof LAID.Take ) { // is LAID.Take



      // TODO: check if any of the attrvalue's takes
      // have not been initialized yet or are dirty for
      // recalculation

      if ( !this.isTaken ) {
        if ( !this.take() ) {
          return false;
        }
      }
      this.isTaken = true;

      reCalc = this.value.execute( this );
      if ( reCalc !== this.calcValue ) {

        isDirty = true;
        this.calcValue = reCalc;
      }
    } else {

      if ( this.value !== this.calcValue ) {

        isDirty = true;

      }
    }

    if ( isDirty ) {
      var
      stateName = getStateNameOfAttrState( this.attr ),
      whenEventType = getWhenEventTypeOfAttrWhen( this.attr ),
      transitionAttr = getTransitionAttrOfAttrTransition( this.attr )
      ;

      this.valueUsedForLastRecalculation = this.value;

      for ( i = 0, len = this.takerAttrValueS.length; i < len; i++ ) {
        takerAttrValueS.requestRecalculation();
      }


      if (
        ( stateName !== "" ) &&
        LAID.$arrayUtils.pushUnique( this.level.$stateS, stateName )
      ) {
        this.level.$updateStates();

      } else if ( whenEventType !== "" ) {

        this.$updateWhenEventType( whenEventType );

      } else if ( transitionAttr !== "" ) {

        this.$updateTransitionAttr( transitionAttr );

      }


    }


  };

  AttrValue.prototype.give = function ( attrValue ) {
    LAID.$arrayUtils.pushUnique( this.takerAttrValueS, attrValue );
  };
  AttrValue.prototype.giveNot = function ( attrValue ) {
    LAID.$arrayUtils.remove( this.takerAttrValueS, attrValue );
  };


  AttrValue.prototype.take = function () {

    if ( this.value instanceof LAID.Take ) {
      var _relPath00attr_S, relPath, level, attr,
      i, len;
      // value is of type `LAID.Take`
      _relPath00attr_S = this.value._relPath00attr_S;

      for ( i = 0, len = _relPath00attr_S.length; i < len; i++ ) {

        relPath = _relPath00attr_S[ i ][ 0 ];
        attr = _relPath00attr_S[ i ][ 1 ];

        level = relPath.resolve( this.level );
        if ( ( level === undefined ) || ( level.$getAttrValue( attr ) === undefined ) ) {
          return false;
        }

      }

      for ( i = 0; i < len; i++ ) {

        relPath = _relPath00attr_S[ i ][ 0 ];
        attr = _relPath00attr_S[ i ][ 1 ];

        relPath.resolve( this.level ).$getAttrValue( attr ).give( this );

      }
    }

  };

  AttrValue.prototype.takeNot = function ( attrValue ) {

    if ( this.value instanceof LAID.Take ) {
      var _relPath00attr_S, relPath, level, attr;
      _relPath00attr_S = this.value._relPath00attr_S;

      for ( var i = 0, len = _relPath00attr_S.length; i < len; i++ ) {

        relPath = _relPath00attr_S[ i ][ 0 ];
        attr = _relPath00attr_S[ i ][ 1 ];

        level = relPath.resolve( this.level );
        if ( ( level === undefined ) && ( level.$getAttrValue( attr ) !== undefined ) ) {
          level.$getAttrValue( attr ).giveNot( this );
        }
      }
    }

  };

  // inspiration from https://github.com/koenbok/Framer/blob/master/framer/Animators/
  function LinearAnimator () {

  }
  LinearAnimator.prototype.next = function ( delta ) {

  };
  LinearAnimator.prototype.done = function () {

  };




})();
