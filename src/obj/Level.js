( function () {
  "use strict";


  function checkIsValidLevelName( levelName ) {

    return ( /^[\w\-]+$/ ).test( levelName );
  }


  LAID.Level = function ( path, lson, parent ) {

    this.path = path;
    this.parentLevel = parent; // parent Level
    // True if the Level is a Part Level,
    // false if the Level is a Many Level.
    this.isPart = undefined;
    // This is relevant if the Level is a Part.
    // If true it implies that this Part
    // has been generated by a Many Level.
    this.isManyDerived = undefined;

    // If the Level is a Many (i.e this.isPart is false)
    // then this.many will hold a reference to the corresponding
    // Many object.
    this.part = undefined;
    // If the Level is a Many (i.e this.isPart is false)
    // then this.many will hold a reference to the corresponding
    // Many object.
    this.many = undefined;
    // If the Level is derived from a Many Level
    // (i.e this.isManyDerived is true)
    // then this.derivedMany will hold
    // a reference to that Many object
    this.derivedMany = undefined;

    this.$lson = lson;

    this.$attr2attrValue = {};
    this.recalculateDirtyAttrValueS = [];
    this.renderDirtyAttrValueS = [];

    this.$childLevelS = [];

    this.$stateS = [];
    this.$stringHashedStates2_cachedAttr2val_ =  {};
    this.$newlyInstalledStateS = [];
    this.$newlyUninstalledStateS = [];


    this.$whenEventType2fnMainHandler = {};

    this.$naturalWidthLevel = undefined;
    this.$naturalHeightLevel = undefined;



  };



  LAID.Level.prototype.$init = function () {

    var necessaryReadonlyPropS = [ "$naturalWidth", "$naturalHeight", "$numberOfChildren",
    "$absoluteLeft", "$absoluteTop" ], i, len;


    LAID.$path2level[ this.path ] = this;

    if ( !LAID.$isClogged ) {
      LAID.$newLevelS.push( this );
      if ( !LAID.$isSolvingNewLevels ) {
        LAID.$solveForNew();
      }

    } else {
      LAID.$cloggedLevelS.push( this );
    }

    for ( i = 0, len = necessaryReadonlyPropS.length; i < len; i++ ) {
      this.$attr2attrValue[ necessaryReadonlyPropS[ i ] ] =
      new AttrValue( necessaryReadonlyPropS[ i ], this );
    }
    this.$attr2attrValue.$numberOfChildren.update( 0 );
    this.$attr2attrValue.$naturalWidth.update( 0 );
    this.$attr2attrValue.$naturalHeight.update( 0 );


  };

  LAID.Level.prototype.addChildren = function ( name2lson ) {

    var childPath, childLevel, name;
    if ( name2lson !== undefined ) {
      for ( name in name2lson ) {

        if ( !checkIsValidLevelName( name ) ) {
          throw ( "LAID Error: Invalid Level Name: " + name );
        }

        childPath = this.path + '/' + name;
        if ( LAID.$path2level[ childPath ] !== undefined ) {
          throw ( "LAID Error: Level already exists with path: " + childPath );
        }
        childLevel = new LAID.Level( childPath, name2lson[ name ], this );
        this.$childLevelS.push( childLevel );
        childLevel.$init();

        this.$attr2attrValue.$numberOfChildren.update( ++this.$attr2attrValue.$numberOfChildren.value );
      }
    }

  };


  /*
  * Return false if the level could not be inherited (due
  * to another level not being present or started as yet)
  * Else add the level's children to the tree and return true
  */
  LAID.Level.prototype.$inheritAndReproduce = function () {

    var lson, refS, i, len, ref, level, inheritedAndNormalizedLson;

    LAID.$normalize( lson, false );
    if ( this.$lson.inherits !== undefined ) { // does not contain anything to inherit from

      lson = { type: "none" };
      refS = this.$lson.inherits;
      for ( i = 0, len = refS.length; i < len; i++ ) {

        ref = refS[ i ];
        if ( typeof ref === "string" ) { // pathname reference

          level = ( new LAID.Path( ref ) ).resolve( this );
          if ( level === undefined || !level.$isStarted ) {

            return false;

          }
        }
      }
      for ( i = 0; i < len; i++ ) {

        ref = refS[ i ];
        if ( typeof ref === "string" ) { // pathname reference

          level = ( new LAID.Path( ref ) ).resolve( this );
          inheritedAndNormalizedLson = level.$lson;

        } else { // object reference
          inheritedAndNormalizedLson = LAID.$normalize( ref, true );
        }

        LAID.$inherit( lson, inheritedAndNormalizedLson, false, false );
      }

      LAID.$inherit( lson, this.$lson, false, false );
      this.$lson = lson;
    }


    if ( this.$lson.children !== undefined ) {
      this.addChildren( $lson.children );
    }

    this.isPart = this.$lson.many === undefined;

    if ( this.isPart ) {
      this.part = new LAID.Part( this );
      this.part.$init();
      LAID.$newPartS.push( this.part );
    } else {
      this.many = new LAID.Many( this );
    }

    return true;

  };



  function initAttrsObj( attrPrefix, key2val, attr2val ) {

    var key, val;

    for ( key in key2val ) {
      attr2val[ attrPrefix + key ] = key2val[ key ];
    }
  }

  function initAttrsArray( attrPrefix, elementS, attr2val ) {

    var i, len;

    for ( i = 0, len = attrS.length ; i < len; i++ ) {
      attr2val[ attrPrefix + i ] = elementS[ i ];
    }
  }

  /* Flatten the slson to attr2val dict */
  function convertSLSONtoAttr2Val( slson, attr2val, statePrefix, isRootState ) {

    var prop,
    transitionProp, transitionDirective,
    transitionPropPrefix,
    eventType, fnCallbackS,
    prop2val = slson.props,
    eventType2fnCallbackS = slson.when,
    transitionProp2directive = slson.transition,
    i, len;


    initAttrsObj( statePrefix, slson.props, attr2val );

    for ( transitionProp in transitionProp2directive ) {
      transitionDirective = transition[ transitionProp ];
      transitionPropPrefix = statePrefix + "transition." + transitionProp + ".";
      if ( transitionDirective.type !== undefined ) {
        attr2val[ transitionPropPrefix + "type" ] = transitionDirective.type;
      }
      if ( transitionDirective.duration !== undefined ) {
        attr2val[ transitionPropPrefix + "duration" ] = transitionDirective.duration;
      }
      if ( transitionDirective.delay !== undefined ) {
        attr2val[ transitionPropPrefix + "delay" ] = transitionDirective.delay;
      }
      if ( transitionDirective.done !== undefined ) {
        attr2val[ transitionPropPrefix + "done" ] = transitionDirective.done;
      }
      if ( transitionDirective.args !== undefined ) {
        initAttrsObj( transitionPropPrefix, transitionDirective.args, attr2val );
      }
    }

    for ( eventType in eventType2fnCallbackS ) {
      fnCallbackS = eventType2fnCallbackS[ eventType ];
      initAttrsArray( statePrefix + "when." + eventType, fnCallbackS, attr2val );
    }

    if ( slson.$$num !== undefined ) {
      initAttrsObj( statePrefix + "$$num.", slson.$$num, attr2val );
    }

    if ( slson.$$max !== undefined ) {
      initAttrsObj( statePrefix + "$$max.", slson.$$max, attr2val );
    }

    /*if ( slson.$$keys !== undefined ) {initAttrsObj( statePrefix + "$$keys.", slson.$$keys, attr2val );}*/



    if ( !isRootState ) {
      attr2val[ statePrefix + "onlyif" ] = slson.onlyif;
      attr2val[ statePrefix + "install" ] = slson.install;
      attr2val[ statePrefix + "uninstall" ] = slson.uninstall;
    }
  }

  LAID.Level.prototype.$initAllAttrs = function () {

    var
    eventReadonly2defaultVal = LAID.$eventReadonlyUtils.getEventReadonly2defaultVal(),
    eventReadonly,
    observableEventReadonlyS = this.$lson.observe,
    observableEventReadonly, i, len;


    for ( eventReadonly in eventReadonly2defaultVal ) {
      this.$attr2attrValue[ eventReadonly ] = new AttrValue( eventReadonly, this );
    }

    if ( observableEventReadonlyS !== undefined ) {
      for ( i = 0, len = observableEventReadonlyS.length; i < len; i++ ) {
        observableEventReadonly = observableEventReadonlyS[ i ];
        if ( eventReadonly2defaultVal[ observableEventReadonly ] === undefined ) {
          console.error("LAID Warning: Non Event Read-Only: " + observableEventReadonly );
        } else {
          this.$attr2attrValue[ observableEventReadonly ].give( $emptyAttrValue );
        }
      }
    }

    this.$initNonStateProjectedAttrs();
    this.$updateStates();


  };

  LAID.Level.prototype.$initNonStateProjectedAttrs = function () {

    var i, key, val, stateName, state,

    states = this.$lson.states, when = this.$lson.when,
    transition = this.$lson.transition,
    attr2val = {};



    initAttrsObj( "data.", this.$lson.data, attr2val );

    convertSLSONtoAttr2Val( this.$lson, attr2val, "root.", true );


    for ( stateName in states ) {
      convertSLSONtoAttr2Val( states[ stateName ] , attr2val, stateName + ".", false );
    }

    this.$commitAttr2Val( attr2val );

  };

  LAID.Level.prototype.$commitAttr2Val = function ( attr2val ) {

    var attr;
    for ( attr in attr2val ) {
      val = attr2val[ attr ];
      attrValue = this.$attr2attrValue[ attr ];
      if ( ( attrValue === undefined ) ) {
        attrValue = this.$attr2attrValue[ attr ] = new AttrValue( this, attr );
      }
      attrValue.update( val );

    }
  };

  /*
  * Solve by recalculating each attr within the
  * level which requires recalculation
  * Return 1 if all attributes were solved
  * Return 2 if some attributes were solved
  * Return 3 if no attributes were solved
  */
  LAID.Level.prototype.$solveForRecalculation = function () {

    var i, len,
    isSolveProgressed,
    isSolvedProgressedOnce = false,
    recalculateDirtyAttrValueS = this.$recalculateDirtyAttrValueS;


    do {
      isSolveProgressed = false;
      for ( i = 0, len = recalculateDirtyAttrValueS.length; i < len; i++ ) {
        isSolveProgressed = recalculateDirtyAttrValueS[ i ].recalculate() || true;
        if ( isSolveProgressed ) {
          isSolvedProgressedOnce = true;
          LAID.$arrayUtils.removeAtIndex( recalculateDirtyAttrValueS, i );
          i--;
        }
      }

      // The reason we will not use `len` to check the length below is
      // that more recalculate dirty levels could have been added during
      // the loop
    } while ( ( recalculateDirtyLevelS.length !== 0 ) && isSolveProgressed );


    return recalculateDirtyLevelS.length === 0 ? 1 : ( isSolveProgressedOnce ? 2 : 3 );

  };

  /*
  Undefine all current attributes which are influencable
  by states: props, transition, when, $$num, $$keys, $$max
  */
  LAID.Level.prototype.$undefineStateProjectedAttrs = function() {

    var attr;
    for ( attr in this.$attr2attrValue ) {
      if ( this.$attr2attrValue[ attr ].isStateProjectedAttr ) {
        this.$attr2attrValue[ attr ].update( undefined );
      }
    }
  };





  /* Return the attr2value generated
  by the current states */
  LAID.Level.prototype.getStateAttr2val = function () {

    if ( this.isManyDerived ) {
      // TODO: get from Many object
    } else {
      var stringHashedStates = this.states.sort().join("&");
      if ( this.stringHashedStates2_cachedAttr2val_[ stringHashedStates ] === undefined ) {
        this.stringHashedStates2_cachedAttr2val_[ stringHashedStates ] =
        convertSLSONtoAttr2Val( this.generateSLSON(), {}, "", true );
      }
      return this.stringHashedStates2_cachedAttr2val_[ stringHashedStates ];
    }

  };


  /*
  *  From the current states generate the
  *  correspinding SLSON (state projected lson)
  *  Requirement: the order of states must be sorted
  */
  LAID.Level.prototype.generateSLSON =  function () {

    this.$stateS.sort();

    var slson = {}, attr2val;

    LSON.$inherit( slson, this.$lson, true, true );
    for ( var i = 0, len = this.$stateS.length; i < len; i++ ) {
      LSON.$inherit( slson, this.$lson.states[ this.$stateS[ i ] ] , true, true );
    }

    return slson;

  };




  LAID.Level.prototype.$updateStates = function () {

    var
    attr2val = this.getStateAttr2val(),
    attr, val,
    attrValue,
    i, len;

    // TODO: fix this outdated comment below
    //
    // state projected attributes are those attributes which
    // can be (key-)value modified by a state. This essentially
    // includes keys within "props", "when", and "transition".
    //
    // Get the entire list of state projected attributes with
    // the motive of removing (splicing) those attributes which
    // have been modified by the state. Ideally the list should
    // be empty at the end of

    // Algorithm
    //
    // allATTRS = filter(curATTRS)
    // for ATTR in (stateProjected) newATTRS
    //   dirty ATTR (=new value)
    //   remove ATTR from allATTRS
    // for ATTR in allATTRS
    //   dirty ATTR (=undefined)
    //

    this.$undefineStateProjectedAttrs();
    this.$commitAttr2Val( attr2val );

  };


  LAID.Level.prototype.attr = function ( attr ) {
    return this.$attr2attrValue[ attr ].calcValue;
  };

  LAID.Level.prototype.data = function ( dataKey, value ) {
    this.$changeAttrVal( "data." + dataKey, value );
  };

  LAID.Level.prototype.$getAttrVal = function ( attr ) {
    return this.$attr2attrValue[ attr ];
  };

  /* Manually change attr value */
  LAID.Level.prototype.$changeAttrVal = function ( attr, val ) {
    this.level.attr2attrValue[ attr ].update( val );
    LAID.$solveForRecalculation();
  };

  LAID.Level.prototype.$addRecalculateDirtyAttrValue = function ( attrValue ) {

    LAID.$arrayUtils.pushUnique( this.$recalculateDirtyAttrValueS, attrValue );
    LAID.$arrayUtils.pushUnique( LAID.$recalculateDirtyLevelS, this );

  };

  LAID.Level.prototype.$addRenderDirtyAttrValue = function ( attrValue ) {

    LAID.$arrayUtils.pushUnique( this.$renderDirtyAttrValueS, attrValue );
    LAID.$arrayUtils.pushUnique( LAID.$renderDirtyLevelS, this );

  };

  LAID.Level.prototype.$findChildWithMaxOfAttr = function ( attr ) {
    var
      i, len, curMaxVal, curMaxLevel,
       childLevels = this.$childLevelS,
       childLevel, childLevelAttrValue;
    for ( i = 0, len = childLevelS.length; i < len; i++ ) {
      childLevel = childLevelS[ i ];
      childLevelAttrValue = childLevel.attr2attrValue[ attr ];
      if ( curMaxLevel === undefined ) {
        curMaxLevel = childLevel;
        curMaxVal = childLevelAttrValue
      } else if ( ( childLevelAttrValue !== undefined ) && ( childLevelAttrValue.calcValue > curMaxVal )  ) {
        curMaxLevel = childLevel;
      }
    }
    return curMaxLevel;
  };



  LAID.Level.prototype.$updateNaturalWidthFromChild = function ( childLevel ) {

    if ( this.$attr2attrValue.$naturalWidth.takerAttrValueS.length ) {

      if ( this.$naturalWidthLevel === childLevel ) {
        if ( ( this.$attr2attrValue.$naturalWidth === undefined ) ) {
          this.$naturalWidthLevel = childLevel;
        // Check If the current child level responsible for the stretch
        // of the naturalWidth boundary, has receeded
        // If this would be the case, then there is
        // a possibility that it has receded behind another
        // child element which has a higher right position
        // than the current child level responsible for the natural width
        } else if ( this.$attr2attrValue.$naturalWidth > childLevel.$attr2attrValue.right.calcValue  ) {
          // Find the child with the next largest right
          // This could be the same child level
          this.$naturalWidthLevel = this.$findChildWithMaxOfAttr( "right" );
        }
      } else {
        if ( childLevel.$attr2attrValue.right.calcValue >
          this.$naturalWidthLevel.$attr2attrValue.right.calcValue ) {
            this.$naturalWidthLevel = childLevel;
        }
      }
      this.$attr2attrValue.$naturalWidth.update( this.$naturalWidthLevel.$attr2attrValue.right.calcValue );
    }
  };


  LAID.Level.prototype.$updateNaturalHeightFromChild = function ( childLevel ) {

    if ( this.$attr2attrValue.$naturalHeight.takerAttrValueS.length ) {

      if ( this.$naturalHeightLevel === childLevel ) {
        if ( ( this.$attr2attrValue.$naturalHeight === undefined ) ) {
          this.$naturalHeightLevel = childLevel;
          // Check If the current child level responsible for the stretch
          // of the naturalHeight boundary, has receeded
          // If this would be the case, then there is
          // a possibility that it has receded behind another
          // child element which has a higher bottom position
          // than the current child level responsible for the natural height
        } else if ( this.$attr2attrValue.$naturalHeight > childLevel.$attr2attrValue.bottom.calcValue  ) {
          // Find the child with the next largest bottom
          // This could be the same child level
          this.$naturalHeightLevel = this.$findChildWithMaxOfAttr( "bottom" );
        }
      } else {
        if ( childLevel.$attr2attrValue.bottom.calcValue >
          this.$naturalHeightLevel.$attr2attrValue.bottom.calcValue ) {
            this.$naturalHeightLevel = childLevel;
          }
        }
        this.$attr2attrValue.$naturalHeight.update( this.$naturalHeightLevel.$attr2attrValue.bottom.calcValue );
      }
  };

  LAID.Level.prototype.$updateNaturalWidthFromText = function () {
    if ( this.$attr2attrValue.$naturalWidth.takerAttrValueS.length ) {
      var textWidthTestNode = document.body.childNodes[ 0 ];
      textWidthTestNode.innerHTML = this.$attr2attrValue.text.calcValue;
      this.$attr2attrValue.$naturalWidth.update( ( textWidthTestNode.getBoundingClientRect().width ) +
        ( this.attr2attrValue.textPaddingLeft !== undefined ? this.attr2attrValue.textPaddingLeft.calcValue : 0  ) +
        ( this.attr2attrValue.textPaddingRight !== undefined ? this.attr2attrValue.textPaddingRight.calcValue : 0  )
      );
    }
  };



  LAID.Level.prototype.$updateNaturalHeightFromText = function () {

    if ( this.$attr2attrValue.$naturalHeight.takerAttrValueS.length ) {

      var textHeightTestNode = document.body.childNodes[ 1 ];
      textHeightTestNode.innerHTML = this.$attr2attrValue.text.calcValue;
      textHeightTestNode.style.width = this.$attr2attrValue.width.calcValue;
      if ( textHeightTestNode.style.textPaddingLeft !== undefined ) {
        textHeightTestNode.style.textPaddingLeft = this.$attr2attrValue.textPaddingLeft.calcValue;
      }
      if ( textHeightTestNode.style.textPaddingRight !== undefined ) {
        textHeightTestNode.style.textPaddingRight = this.$attr2attrValue.textPaddingRight.calcValue;
      }

      this.$attr2attrValue.$naturalHeight.update( ( textWidthTestNode.getBoundingClientRect().height ) +
        ( this.attr2attrValue.textPaddingTop !== undefined ? this.attr2attrValue.textPaddingTop.calcValue : 0  ) +
        ( this.attr2attrValue.textPaddingBottom !== undefined ? this.attr2attrValue.textPaddingBottom.calcValue : 0  )
      );

    }
  };


  LAID.Level.prototype.$updateWhenEventType = function ( eventType ) {

    var
    numFnHandlersForEventType = this.$attr2attrValue[ "$$num." + eventType ],
    fnMainHandler,
    thisLevel = this;

    if ( this.$whenEventType2fnMainHandler[ eventType ] !== undefined ) {
      LAID.$eventUtils.remove( this.$part.node, eventType, prevWrapperEventHandlerS[ i ] );
    }

    if ( numFnHandlers !== 0 ) {
      fnMainHandler = function ( e ) {
        var i, len, attrValueForFnHandler;
        for ( i = 0; i < numFnHandlersForEventType; i++ ) {
          attrValueForFnHandler = thisLevel.attr2attrValue[ "when." + eventType + ( i + 1 ) ];
          if ( attrValueForFnHandler !== undefined ) {
            attrValueForFnHandler.calcValue.call( thisLevel, e );
          }
        }
      };
      LAID.$eventUtils.add( this.$part.node, eventType, fnMainHandler );
      this.$whenEventType2fnMainHandler[ eventType ] = fnMainHandler;

    } else {
      this.$whenEventType2fnMainHandler[ eventType ] = undefined;

    }
  };

  LAID.Level.prototype.$checkIsPropInTransition = function ( prop ) {
    return this.$attr2attrValue[ "transition." + transitionProp  + ".type" ] ===
    undefined;
  };

  LAID.Level.prototype.$updateTransitionProp = function ( transitionProp ) {

    var
    origTransitionProp,
    transitionPrefix,
    transitionType, transitionDuration, transitionDelay,
    transitionArgS, transitionArg2val = {},
    transitionObj,
    i, len,
    longhandPropS,
    affectedPropS,
    affectedProp,
    affectedPropAttrValue;


    if ( ( [ "centerX", "right", "centerY", "bottom" ] ).indexOf( transitionProp ) !== -1  ) {
      return;
    }

    if ( !this.$checkIsPropInTransition( transitionProp ) ) {
      origTransitionProp = transitionProp;
      transitionProp = LAID.$shorthandPropsUtils.getShorthandProp( transitionProp );
      if ( transitionProp !== undefined ) {
        if ( this.$checkIsPropInTransition( transitionProp ) ) {
          return;
        } else {
          affectedProp = origTransitionProp;
        }
      }
    }

    transitionPrefix = "transition." + transitionProp + ".";
    transitionType = this.$attr2attrValue[ transitionPrefix + "type" ].calcValue;
    transitionDuration =
    ( this.$attr2attrValue[ transitionPrefix + "duration" ] ?
    this.$attr2attrValue[ transitionPrefix + "duration" ].calcValue :
    0 );
    transitionDelay = ( this.$attr2attrValue[ transitionPrefix + "delay" ] ?
    this.$attr2attrValue[ transitionPrefix + "delay" ].calcValue :
    0 );
    transitionArgS = LAID.$transitionType2args[ transitionType ];

    for ( i = 0, len = transitionArgS.length; i < len; i++ ) {
      transitionArg2val[ transitionArgS[ i ] ] = ( this.$attr2attrValue[ transitionPrefix + "arg." + transitionArgS[ i ]  ] ?
      this.$attr2attrValue[ transitionPrefix + "arg." + transitionArgS[ i ] ].calcValue : [] );
    }

    longhandPropS = LAID.$shorthandPropsUtils.getLonghandProps( transitionProp );

    if ( longhandPropS !== undefined ) {
      affectedPropS = longhandPropS;
      for ( i = 0, len = affectedPropS.length; i < len; i++ ) {
        affectedProp = affectedPropS[ i ];
        if ( !this.$checkIsPropInTransition ) {
          affectedPropAttrValue = this.$attr2attrValue[ affectedProp ];

          if ( affectedPropAttrValue !== undefined && affectedPropAttrValue.transitionCalcValue && affectedPropAttrValue.calcValue ) {
            affectedPropAttrValue.transition = LAID.$transitionType2object[ transitionType ] ( affectedPropAttrValue.transitionCalcValue, transitionDuration, transitionDelay, transitionDone, transitionArg2val );
            LAID.$arrayUtils.pushUnique( this.transitionDirtyAttrValueS, propAttrValue );
          }
        }

      }
    } else {

      affectedPropAttrValue = this.$attr2attrValue[ affectedProp || transitionProp ];
      if ( affectedPropAttrValue !== undefined && affectedPropAttrValue.transitionCalcValue && affectedPropAttrValue.calcValue ) {
        affectedPropAttrValue.transition = LAID.$transitionType2object[ transitionType ] ( affectedPropAttrValue.transitionCalcValue, transitionDuration, transitionDelay, transitionDone, transitionArg2val );
        LAID.$arrayUtils.pushUnique( this.transitionDirtyAttrValueS, propAttrValue );
      }

    }
  };



  /*
  * For attrs which are of type state ( i.e state.<name> )
  * Return the name component.
  * Else return the empty string.
  */
  function getStateNameOfAttrState ( attr ) {

    return attr.startsWith( "state." ) ?
    attr.slice( 6 ) : "";

  }

  /*
  * For attrs which are of type when ( i.e state.<eventType><eventNum> )
  * Return the event type component.
  * Else return the empty string.
  */
  function getWhenEventTypeOfAttrWhen ( attr ) {

    return attr.startsWith( "when." ) ?
    attr.slice( 5, attr.length - 1 ) : "";

  }


  function checkIsStateProjectedAttr( attr ) {
    var i = attr.indexOf( "." );
    if ( i === -1 ) {
      return true;
    } else {
      var prefix = attr.slice( 0, i );
      return ( ( [ "when", "transition", "$$num", "$$max", /*"$$keys"*/ ] ).indexOf( prefix ) !== -1 );
    }
  }

  // The naming convention:
  // attr -> string attr name
  // attrValue -> class AttrValue
  function AttrValue ( attr, level ) {

    // undefined initializations:
    // (1) performance (http://jsperf.com/objects-with-undefined-initialized-properties/2)
    // (2) readability

    this.level = level;
    this.value = undefined;
    this.valueUsedForLastRecalculation = undefined;
    this.isTaken = undefined;
    this.attr = attr;

    this.calcValue = undefined;
    this.transitionCalcValue = undefined;
    this.transition = undefined;

    this.isStateProjectedAttr = checkIsStateProjectedAttr( attr );
    this.isEventReadonlyAttr = LAID.$eventReadonlyUtils.checkIsEventReadonlyAttr( attr );
    this.renderCall = level.isPart && LAID.$findRenderCall( attr );

    this.takerAttrValueS = [];

    this.eventReadonlyEventType2boundFnHandler = {};

  }

  /* TODO: update this doc below along with its slash-asterisk
  formatting

  Returns true if the value is different,
  false otherwise */
  AttrValue.prototype.update = function ( value ) {

    this.value = value;

    if ( value !== this.valueUsedForLastRecalculation ) {

      if ( this.value instanceof LAID.Take ) {
        this.takeNot();
      }

      this.value = value;
      this.isTaken = false;
      this.requestRecalculation();

      return true;

    }

  };

  /*
  * Request the level corresponding to the given AttrValue
  * to recalculate this AttrValue.
  */
  AttrValue.prototype.requestRecalculation = function () {
    this.level.$addRecalculateDirtyAttrValue( this );
  };


  /*
  * TODO: update this doc below
  *
  * Recalculate the value of the attr value.
  * Propagate the change across the LOM (LAID object model)
  * if the change in value produces a change.
  * For constraint (take) based attributes, recalculate the
  * value, for non constraint based use the `value` parameter
  * as the change.
  * Return true if calculation successful, false if
  * a circular reference rendered it unsuccessful
  */
  AttrValue.prototype.recalculate = function () {

    var
    isDirty = false,
    reCalc,
    level = this.level,
    i, len;

    if ( this.value instanceof LAID.Take ) { // is LAID.Take
      if ( !this.isTaken ) {
        if ( !this.take() ) {
          return false;
        }
      }
      this.isTaken = true;

      reCalc = this.value.execute( this );
      if ( reCalc !== this.calcValue ) {

        isDirty = true;
        this.calcValue = reCalc;
      }
    } else {
      if ( this.value !== this.calcValue ) {
        this.calcValue = this.value;
        isDirty = true;
      }
    }

    if ( isDirty ) {
      var
      attr = this.attr,
      stateName = getStateNameOfAttrState( attr ),
      whenEventType = getWhenEventTypeOfAttrWhen( attr ),
      transitionProp = getTransitionPropOfAttrTransition( attr );

      this.valueUsedForLastRecalculation = this.value;

      for ( i = 0, len = this.takerAttrValueS.length; i < len; i++ ) {
        takerAttrValueS.requestRecalculation();
      }

      if ( this.renderCall ) {
        level.$addRenderDirtyAttrValue( this );

        if ( ( this.attr === "text" ) ||
            ( this.attr.startsWith( "textPadding" ) )
          )  {
          level.$updateNaturalWidthFromText();
          level.$updateNaturalHeightFromText();
        }

      } else if ( stateName !== "" ) {
        if ( this.calcValue ) { // state
          if ( LAID.$arrayUtils.pushUnique( level.$stateS, stateName ) ) {
            level.$updateStates();
            // remove from the list of uninstalled states (which may/may not be present within)
            LAID.$arrayUtils.remove( level.$newlyUninstalledStateS, stateName );
            // add state to the list of newly installed states
            LAID.$arrayUtils.pushUnique( level.$newlyInstalledStateS, stateName );
            // add level to the list of levels which have newly installed states
            LAID.$arrayUtils.pushUnique( LAID.$newlyInstalledStateLevelS, level );
          }
        } else { // remove state
          if ( LAID.$arrayUtils.remove( level.$stateS, stateName ) ) {
            level.$updateStates();
            // remove from the list of installed states (which may/may not be present within)
            LAID.$arrayUtils.remove( level.$newlyInstalledStateS, stateName );
            // add state to the list of newly uninstalled states
            LAID.$arrayUtils.pushUnique( level.$newlyUninstalledStateS, stateName );
            // add level to the list of levels which have newly uninstalled states
            LAID.$arrayUtils.pushUnique( LAID.$newlyUninstalledStateLevelS, level );
          }
        }
      } else if ( whenEventType !== "" ) {
        this.$updateWhenEventType( whenEventType );
      } else if ( transitionProp !== "" ) {
        this.$updateTransitionProp( transitionProp );
      } else if ( attr === "right" ) {
        if ( level.parentLevel !== undefined ) {
          level.parentLevel.$updateNaturalWidthFromChild( level );
        }
      } else if ( attr === "bottom" ) {
        if ( level.parentLevel !== undefined ) {
          level.parentLevel.$updateNaturalHeightFromChild( level );
        }
      }


    }


  };

  AttrValue.prototype.give = function ( attrValue ) {
    if ( LAID.$arrayUtils.pushUnique( this.takerAttrValueS, attrValue ) && this.takerAttrValueS.length === 1 ) {
      if ( this.isEventReadonlyAttr ) {
        // Given that a reference exists, add event listeners
        var
        eventType2fnHandler = LAID.$eventReadonlyUtils.getEventType2fnHandler( this.attr ),
        eventType,
        fnBoundHandler;
        for ( eventType in eventType2fnHandler ) {
          fnBoundHandler = eventType2fnHandler[ eventType ].bind( this );
          LAID.$eventUtils.add( this.$part.node, eventType, fnBoundHandler );
          this.eventReadonlyEventType2boundFnHandler[ eventType ] = fnBoundHandler;
        }
      }
    }
  };
  AttrValue.prototype.giveNot = function ( attrValue ) {
    if ( LAID.$arrayUtils.remove( this.takerAttrValueS, attrValue ) && this.takerAttrValueS.length === 0 ) {
      if ( this.isEventReadonlyAttr ) {
        // Given that no reference exists, remove event listeners
        var
        eventType2fnHandler = LAID.$eventReadonlyUtils.getEventType2fnHandler( this.attr ),
        eventType,
        fnBoundHandler;
        for ( eventType in eventType2fnHandler ) {
          fnBoundHandler = eventReadonlyEventType2boundFnHandler[ eventType ];
          LAID.$eventUtils.remove( this.$part.node, eventType, fnBoundHandler );
          this.eventReadonlyEventType2boundFnHandler[ eventType ] = undefined;
        }
      }
    }
  };


  AttrValue.prototype.take = function () {

    if ( this.value instanceof LAID.Take ) {
      var _relPath00attr_S, relPath, level, attr,
      i, len;
      // value is of type `LAID.Take`
      _relPath00attr_S = this.value._relPath00attr_S;

      for ( i = 0, len = _relPath00attr_S.length; i < len; i++ ) {

        relPath = new LAID.RelPath( _relPath00attr_S[ i ][ 0 ] );
        attr = _relPath00attr_S[ i ][ 1 ];

        level = relPath.resolve( this.level );
        if ( level === undefined ) {
          return false;
        }
        if ( level.$getAttrValue( attr ) === undefined )  {
          if ( eventReadonly2_eventType2fnHandler_[ attr  ] !== undefined ) {
            level.$referenceEventReadonlyAttr( attr );

          }
          if ( !LAID.$checkIsReadonlyAttr( attr ) ) {
            return false;
          }
        }
      }

      for ( i = 0; i < len; i++ ) {

        relPath = new LAID.RelPath( _relPath00attr_S[ i ][ 0 ] );
        attr = _relPath00attr_S[ i ][ 1 ];

        relPath.resolve( this.level ).$getAttrValue( attr ).give( this );

      }
    }

  };

  AttrValue.prototype.takeNot = function ( attrValue ) {

    if ( this.value instanceof LAID.Take ) {
      var _relPath00attr_S, relPath, level, attr;
      _relPath00attr_S = this.value._relPath00attr_S;

      for ( var i = 0, len = _relPath00attr_S.length; i < len; i++ ) {

        relPath = _relPath00attr_S[ i ][ 0 ];
        attr = _relPath00attr_S[ i ][ 1 ];

        level = relPath.resolve( this.level );
        if ( ( level === undefined ) && ( level.$getAttrValue( attr ) !== undefined ) ) {
          level.$getAttrValue( attr ).giveNot( this );
        }
      }
    }

  };

  var $emptyAttrValue = new AttrValue( "", undefined );



})();
