( function () {
  "use strict";

  function checkIsValidLevelName( levelName ) {

    return ( /^[\w\-]+$/ ).test( levelName );
  }

  LAID.Level = function ( path, lson, clogKey, parent ) {

    this.path = path;
    this.parent = parent; // parent Level
    // True if the Level is a Part Level,
    // false if the Level is a Many Level.
    this.isPart = undefined;
    // This is relevant if the Level is a Part.
    // If true it implies that this Part
    // has been generated by a Many Level.
    this.isManyDerived = undefined;

    // If the Level is a Many (i.e this.isPart is false)
    // then this.many will hold a reference to the corresponding
    // Many object.
    this.$part = undefined;
    // If the Level is a Many (i.e this.isPart is false)
    // then this.many will hold a reference to the corresponding
    // Many object.
    this.$many = undefined;
    // If the Level is derived from a Many Level
    // (i.e this.isManyDerived is true)
    // then this.derivedMany will hold
    // a reference to that Many object
    this.$derivedMany = undefined;


    this.$lson = lson;
    this.$isInherited = false;
    this.$dirtyAttrS = [];
    this.$attr2attrValue = {};
    this.$isStateUpdating = false;
    this.$stateS = [];
    // alphabetical order state sort dict?
    this.$stringHashedStates2_cachedAttr2val_ = {};

    if ( lson.children !== undefined ) {
      this.addChildren( lson.children, clogKey );
    }

  };



  LAID.Level.prototype.addChildren = function ( name2lson, clogKey ) {

    if ( clogKey === undefined ) {

      clogKey = ++LAID.$curClogKey;
      LAID.$clogKey2_levelS_[ clogKey ] = [];

    }

    var childPath, childLevel;
    for ( var name in name2lson ) {

      if ( name2lson.hasOwnProperty( name ) ) {

        if ( !checkIsValidLevelName( name ) ) {
          throw ( "LAID Error: Invalid Level Name: " + name );
        }

        childPath = this.path + '/' + name;
        childLevel = new LAID.Level( childPath, name2lson[ name ], clogKey, this );
        LAID.$path2level[ childPath ] = childLevel;
        LAID.$clogKey2_levelS_[ clogKey ].push( childLevel );

      }
    }

  };

  LAID.Level.prototype.$inherit = function() {


    if ( !this.$isInherited ) {
      LAID.$normalize( lson, false );
      if ( this.$lson.inherits === undefined ) { // does not contain anything to inherit from

        this.$isInherited = true;

      } else {
        var lson = {};
        var refS = this.$lson.inherits;
        for ( var i = 0, len = refS.length, ref, level, inheritedAndNormalizedLson; i < len; i++ ) {

          ref = refS[ i ];
          if ( typeof ref === "string" ) { // pathname reference

            level = ( new LAID.Path( ref ) ).resolve( this );
            if ( !level.$inherited ) {

              level.$inherit();

            }

            inheritedAndNormalizedLson = level.lson;

          } else { // object reference

            inheritedAndNormalizedLson = LAID.$normalize( ref, true );

          }

          LAID.$inherit( lson, inheritedAndNormalizedLson, false, false );

        }
        LAID.$inherit( lson, this.$lson, false, false );
        this.$lson = lson;
      }
    }
  };



  LAID.Level.prototype.$initAttrsObj = function ( attrPrefix, key2val ) {

    var key, val;

    for ( key in key2val ) {

      if ( key2val.hasOwnProperty( key ) ) {

        val = key2val[ key ];

        this.$initAttr( attrPrefix + key, elementS[ i ] );

      }
    }
  };

  LAID.Level.prototype.$initAttrsArray = function ( attrPrefix, elementS ) {

    var i, len;

    for ( i = 0, len = attrS.length ; i < len; i++ ) {

      this.$initAttr( attrPrefix + i, elementS[ i ] );

    }
  };

  LAID.Level.prototype.$initAttr = function ( attr, val ) {

    this.attr2attrValue[ attr ] = new AttrValue( attr, this );
    this.attr2attrValue[ attr ].update( val );

  };

  LAID.Level.prototype.$initAttrs = function () {

    var i, key, val, stateName, state,

    states = this.$lson.states, when = this.$lson.when,
    transition = this.$lson.transition;

    this.$initAttrsObj( "", this.$lson.props );
    this.$initAttrsObj( "root.", this.$lson.props );
    this.$initAttrsObj( "data.", this.$lson.data );

    if ( when !== undefined ) {

      for ( key in when ) {
        if ( when.hasOwnProperty( key ) ) {

          this.$initAttrsArray( "when." + key, when[ key ] );
          this.$initAttrsArray( "root.when." + key, when[ key ] );

        }
      }
    }
    if ( transition !== undefined ) {

      for ( key in transition ) {
        if ( transition.hasOwnProperty( key ) ) {

          this.$initAttrsObj( "transition." + key, transition[ key ] );
          this.$initAttrsObj( "root.transition." + key, transition[ key ] );

        }
      }
    }

    for ( stateName in states ) {
      if ( states.hasOwnProperty( stateName ) ) {

        state = states[ key ];


        this.$initAttr( "state." + key, false );
        if ( state.install !== undefined ) { this.$initAttr( stateName + ".install", state.install ); }
          if ( state.uninstall !== undefined ) { this.$initAttr( stateName + ".uninstall", state.uninstall ); }

            when = val.when;
            transition = val.transition;

            this.$initAttrsObj( stateName + ".", state.props );

            if ( when !== undefined ) {
              for ( key in when ) {
                if ( when.hasOwnProperty( key ) ) {

                  this.$initAttrsArray( stateName + ".when." + key, state.when[ key ] );

                }
              }
            }

            if ( transition !== undefined ) {
              for ( key in transition ) {
                if ( transition.hasOwnProperty( key ) ) {

                  this.$initAttrsObj( stateName + ".transition." + key, state.transition[ key ] );

                }
              }
            }
          }
        }



        //this.initAttrsSet( "data.", this.$lson.data );





      };

      /*
      Filter out those attributes which are influencable
      by states: props, transition, when
      */
      LAID.Level.protoype.$filterStateProjectedAttrs = function() {

        var attr, stateProjectedAttrS = [];
        for ( attr in this.attr2attrValue ) {
          if ( this.attr2attrValue.hasOwnProperty( attr ) ) {

            if ( this.attr2attrValue[ attr ].isStateProjectedAttr ) {
              stateProjectedAttrS.push( attr );
            }
          }
        }
        return stateProjectedAttrS;
      };




      /* Return the attr2value generated
      by the current states */
      LAID.Level.prototype.getStateAttrVal = function () {

        if ( this.isManyDerived ) {
          // TODO: get from Many object
        } else {
          var stringHashedStates = this.states.sort().join("&");
          if ( this.stringHashedStates2_cachedAttr2val_[ stringHashedStates ] === undefined ) {
            this.stringHashedStates2_cachedAttr2val_[ stringHashedStates ] =
            convertSLSONtoAttr2Val( this.generateSLSON() );
          }
          return this.stringHashedStates2_cachedAttr2val_[ stringHashedStates ];
        }

      };


      /*
      *  From the current states generate the
      *  correspinding SLSON (state projected lson)
      *  Requirement: the order of states must be sorted
      */
      LAID.Level.prototype.generateSLSON =  function () {

        this.$stateS.sort();

        var slson = {}, attr2val;

        LSON.$inherit( slson, this.$lson, true, true );
        for ( var i = 0, len = this.$stateS.length; i < len; i++ ) {
          LSON.$inherit( slson, this.$lson.states[ this.$stateS[ i ] ] , true, true );
        }

        return slson;

      };

      /* Flatten the slson to attr2val dict */
      function convertSLSONtoAttr2Val( slson ) {

        var prop,
         transitionAttr, transitionDirective, transitionArgs,
         eventType, fnCallbackS,
        props = slson.props, when = slson.when, transition = slson.transition,
        attr2val = {};

        for ( prop in props ) {
          if ( props.hasOwnProperty( prop ) ) {
            attr2val[ prop ] = props[ prop ];
          }
        }

        for ( transitionAttr in transition ) {
          if ( transition.hasOwnProperty( transitionAttr ) ) {
            transitionDirective = transition[ transitionAttr ];
          }
        }


      }


      LAID.Level.protoype.$updateStates = function () {

        var cleanStateProjectedAttrS = this.$filterStateProjectedAttrs(),
        affectedAttrValueS = [];

        >>>>>>>>>>>for looppzz

        attrValue = this.attr2attrValue[ prop ];
        // Attributes which were not included within the
        // root (state), would not have been defined as yet.
        // This is a "lazy" initiliazation method.
        if ( ( attrValue === undefined )  && ( TODO: thisrawval notequals undefined ) ) {
          this.$initAttr( prop, props[ prop ] );
          affectedAttrValueS.push( prop );
        } else {
          if ( attrValue.update( props[ prop ] ) ) {
            affectedAttrValueS.push( prop );
          }
        }
        LAID.$arrayUtils.remove( cleanStateProjectedAttrS, prop );

        >>>>>>>>>>>end forloopps


        // Algorithm
        //
        // allATTRS = filter(curATTRS)
        // for ATTR in (stateProjected) newATTRS
        //   dirty ATTR (=new value)
        //   remove ATTR from allATTRS
        // for ATTR in allATTRS
        //   dirty ATTR (=undefined)
        //



        // state projected attributes are those attributes which
        // can be (key-)value modified by a state. This essentially
        // includes keys within "props", "when", and "transition".
        //
        // Get the entire list of state projected attributes with
        // the motive of removing (splicing) those attributes which
        // have been modified by the state. Ideally the list should
        // be empty at the end of




        // TODO: add changes to `when` and `transition`
        // TODO: solve. what is state changes out here?


      };

      LAID.Level.prototype.$getAttrValue = function ( attr ) {

        return this.$attr2attrValue[ attr ];

      };





      function checkIsAttrState ( attr ) {

        return attr[ 0 ] === "s" &
        attr[ 1 ] === "t" &
        attr[ 2 ] === "a" &
        attr[ 3 ] === "t" &
        attr[ 4 ] === "e" &
        attr[ 5 ] === ".";

      }

      function checkIsAttrData ( attr ) {

        return attr[ 0 ] === "d" &
        attr[ 1 ] === "a" &
        attr[ 2 ] === "t" &
        attr[ 3 ] === "a" &
        attr[ 4 ] === ".";

      }

      LAID.Level.prototype.$prepare = function () {



        var isMany = this.$lson.many !== undefined;
        var lson = isMany ? this.$lson.many : this.$lson;

        this.isPart = true;
        this.part = new LAID.Part( this );
        var dirtyAttrS = this.dirtyAttrS;
        //var attr2attrValue =  this.$attr2attrValue;

        for ( var i = 0, len = dirtyAttrS.length, dirtyAttr; i < len; i++ ) {

          dirtyAttr = dirtyAttrS[ i ];
          if ( !checkIsAttrState( dirtyAttr ) ) {

            this.$cleanifyAttr( dirtyAttr );

          }
        }



      };



      /* Given a list of AttrValues, it recalculates
      * each one. If a persistent
      * cyclic dependency is encountered
      * then false is returned, else true.
      */
      function solveAttrValueCalculation( attrValueS ) {
        var pendingTakerAttrValueS, isSecondTry, i, len, prevLen;
        pendingTakerAttrValueS = LAID.$arrayUtils.cloneSingleLevel( attrValueS );

        isSecondTry = false;

        prevLen = pendingTakerAttrValueS.length;

        while ( true ) {


          for ( i = pendingTakerAttrValueS.length - 1; i + 1; i-- ) {

            if ( pendingTakerAttrValueS[ i ].reCalculate( numReCalcDepth + 1 ) ) {
              pendingTakerAttrValueS.pop();
            }
          }

          if ( pendingTakerAttrValueS.length !== 0 ) {
            if ( prevLen === len ) {
              if ( isSecondTry ) {
                break;
              } else {
                isSecondTry = true;
              }
            }
          } else {
            break;
          }
          prevLen = len;
        }
        return pendingTakerAttrValueS.length === 0;

      }







      function checkIsStateProjectedAttr( attr ) {
        var i = attr.indexOf( "." );
        if ( i === -1 ) {
          return true;
        } else {
          var prefix = attr.slice( 0, i );
          return ( ( [ "when", "transition" ] ).indexOf( prefix ) !== -1 );
        }
      }

      function AttrValue ( attr, level ) {

        // undefined initializations:
        // (1) performance (http://jsperf.com/objects-with-undefined-initialized-properties/2)
        // (2) readability

        this.level = level;
        this.attr = attr;
        this.value = undefined;
        this.isTaker = false;
        this.isStateProjectedAttr = checkIsStateProjectedAttr( attr );


        this.isDirty = false;
        this.isCalculating = false;

        this.calcValue = undefined;
        this.transitionCalcValue = undefined;

        this.transition = undefined;

        this.takerAttrValueS = [];

      }

      /* Returns true if the value is different,
      false otherwise */
      AttrValue.prototype.update = function ( value ) {

        this.isCalculating = false;

        if ( value === this.value ) {

          return false;

        } else {

          if ( this.isTaker ) {
            this.takeNot();
          }

          this.value = value;
          this.isTaker = value instanceof LAID.Take;

          return true;

        }

      };


      /*
      * Recalculate the value of the attr value.
      * Propagate the change across the LOM (LAID object model)
      * if the change in value produces a change.
      * For constraint (take) based attributes, recalculate the
      * value, for non constraint based use the `value` parameter
      * as the change.
      * Return true if calculation successful, false if
      * a circular reference rendered it unsuccessful
      */
      AttrValue.prototype.reCalculate = function ( numReCalcDepth ) {


        var isSolved;

        if ( this.isCalculating ) { // Check for circular reference

          // circular reference
          return false;

        } else {

          isSolved = false;

          this.isCalculating = true;



          if ( this.isTaker ) { // is LAID.Take

            var reCalc = this.value.execute( this );
            if ( reCalc !== this.calcValue ) {

              this.isDirty = true;
              this.calcValue = reCalc;

            }

          } else {

            if ( this.value !== this.transitionCalcValue ) {

              this.isDirty = true;

            }
          }

          // TODO: code for transition change recalculation

          isSolved = ( this.isDirty && ( this.takerAttrValueS.length !== 0 ) ) ?
          solveAttrValueCalculation( this.takerAttrValueS ) : true;

          this.isCalculating = false;
          return isSolved;

        }
      };

      AttrValue.prototype.give = function ( attrValue ) {
        LAID.$arrayUtils.add( this.takerAttrValueS, attrValue );
      };
      AttrValue.prototype.giveNot = function ( attrValue ) {
        LAID.$arrayUtils.remove( this.takerAttrValueS, attrValue );
      };


      AttrValue.prototype.take = function () {

        if ( this.isTaker ) {
          var _relPath00attr_S, relPath, level, attr;
          // value is of type `LAID.Take`
          _relPath00attr_S = this.value._relPath00attr_S;

          for ( var i = 0, len = _relPath00attr_S.length; i < len; i++ ) {

            relPath = _relPath00attr_S[ i ][ 0 ];
            attr = _relPath00attr_S[ i ][ 1 ];

            level = relPath.resolve( this.level );
            if ( level === undefined ) {

              console.error("LAID ERROR: Undefined level relative path: " + relPath.childPath );

            } else {

              level.$getAttrValue( attr ).give( this );
            }
          }
        }

      };

      AttrValue.prototype.takeNot = function ( attrValue ) {

        if ( this.isTaker ) {
          var _relPath00attr_S, relPath, level, attr;
          // value is of type `LAID.Take`
          _relPath00attr_S = this.value._relPath00attr_S;

          for ( var i = 0, len = _relPath00attr_S.length; i < len; i++ ) {

            relPath = _relPath00attr_S[ i ][ 0 ];
            attr = _relPath00attr_S[ i ][ 1 ];

            level = relPath.resolve( this.level );
            if ( level === undefined ) {

              console.error("LAID ERROR: Undefined level relative path: " + relPath.childPath );

            } else {

              level.$getAttrValue( attr ).giveNot( this );
            }
          }
        }

      };

      // inspiration from https://github.com/koenbok/Framer/blob/master/framer/Animators/
      function LinearAnimator () {

      }
      LinearAnimator.prototype.next = function ( delta ) {

      };
      LinearAnimator.prototype.done = function () {

      };




    })();
