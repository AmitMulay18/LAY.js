( function () {
  "use strict";


  


  LAID.Level = function ( path, lson, parent ) {

    this.path = path;
    this.parentLevel = parent; // parent Level
    // True if the Level is a Part Level,
    // false if the Level is a Many Level.
    this.isPart = undefined;
    // This is relevant if the Level is a Part.
    // If true it implies that this Part
    // has been generated by a Many Level.
    this.isManyDerived = undefined;

    // If the Level is a Many (i.e this.isPart is false)
    // then this.many will hold a reference to the corresponding
    // Many object.
    this.part = undefined;
    // If the Level is a Many (i.e this.isPart is false)
    // then this.many will hold a reference to the corresponding
    // Many object.
    this.many = undefined;
    // If the Level is derived from a Many Level
    // (i.e this.isManyDerived is true)
    // then this.derivedMany will hold
    // a reference to that Many object
    this.derivedMany = undefined;

    this.$lson = lson;
    this.$isInherited = false;
    this.$isInitiallyRendered = false;

    this.$attr2attrVal = {};
    //this.$dataTravelAttrValS = [];
    this.$recalculateDirtyAttrValS = [];
    this.$normalRenderDirtyAttrValS = [];
    this.$travelRenderDirtyAttrValS = [];

    this.$childLevelS = [];

    this.$stateS = [];
    this.$stringHashedStates2_cachedAttr2val_ =  {};
    this.$newlyInstalledStateS = [];
    this.$newlyUninstalledStateS = [];


    this.$whenEventType2fnMainHandler = {};

    this.$naturalWidthLevel = undefined;
    this.$naturalHeightLevel = undefined;



  };

  LAID.Level.prototype.$init = function () {

    LAID.$path2level[ this.path ] = this;

    if ( !LAID.$isClogged ) {
      LAID.$newLevelS.push( this );
      if ( !LAID.$isSolvingNewLevels ) {
        LAID.$solveForNew();
      }

    } else {
      LAID.$cloggedLevelS.push( this );
    }

  };


  LAID.Level.prototype.level = function ( relativePath ) {

    return ( new LAID.RelPath( relativePath ) ).resolve( this );
  };
  LAID.Level.prototype.addChildren = function ( name2lson ) {

    var childPath, childLevel, name;
    if ( name2lson !== undefined ) {
      for ( name in name2lson ) {

        if ( !LAID.$checkIsValidUtils.levelName( name ) ) {
          throw ( "LAID Error: Invalid Level Name: " + name );
        }

        childPath = this.path + ( this.path === "/" ? "" : "/" ) + name;
        if ( LAID.$path2level[ childPath ] !== undefined ) {
          throw ( "LAID Error: Level already exists with path: " + childPath );
        }
        childLevel = new LAID.Level( childPath, name2lson[ name ], this );
        this.$childLevelS.push( childLevel );
        childLevel.$init();

      }
    }

  };


  /*
  * Return false if the level could not be inherited (due
  * to another level not being present or started as yet)
  * Else add the level's children to the tree and return true
  */
  LAID.Level.prototype.$inheritAndReproduce = function () {
    var lson, refS, i, len, ref, level, inheritedAndNormalizedLson;

    LAID.$normalize( this.$lson, false );

    // check if it contains anything to inherit from
    if ( this.$lson.inherit !== undefined ) { 
      lson = { type: "none" };
      refS = this.$lson.inherit;
      for ( i = 0, len = refS.length; i < len; i++ ) {

        ref = refS[ i ];
        if ( typeof ref === "string" ) { // pathname reference

          level = ( new LAID.RelPath( ref ) ).resolve( this );
          if ( ( level === undefined ) || !level.$isInherited ) {
            return false;
          }
        }
      }
      for ( i = 0; i < len; i++ ) {

        ref = refS[ i ];
        if ( typeof ref === "string" ) { // pathname reference

          level = ( new LAID.RelPath( ref ) ).resolve( this );
          inheritedAndNormalizedLson = level.$lson;

        } else { // object reference
           LAID.$normalize( ref, true );
           inheritedAndNormalizedLson = ref;
        }

        LAID.$inherit( lson, inheritedAndNormalizedLson, false, false );
      }

      LAID.$inherit( lson, this.$lson, false, false );

      this.$lson = lson;
    }

    LAID.$defaultizeLsonRootProps( this.$lson );

    if ( this.$lson.children !== undefined ) {
      this.addChildren( this.$lson.children );
    }

    this.isPart = this.$lson.many === undefined;

    if ( this.isPart ) {
      this.part = new LAID.Part( this );
      this.part.$init();
      LAID.$newPartS.push( this.part );
    } else {
      this.many = new LAID.Many( this );
    }
    this.$isInherited = true;
    return true;

  };



  function initAttrsObj( attrPrefix, key2val, attr2val ) {

    var key, val;

    for ( key in key2val ) {
      attr2val[ attrPrefix + key ] = key2val[ key ];
    }
  }

  function initAttrsArray( attrPrefix, elementS, attr2val ) {

    var i, len;

    for ( i = 0, len = elementS.length ; i < len; i++ ) {
      attr2val[ attrPrefix + "." + ( i + 1 ) ] = elementS[ i ];
    }
  }

  /* Flatten the slson to attr2val dict */
  function convertSLSONtoAttr2Val( slson, attr2val ) {

    var prop,
    transitionProp, transitionDirective,
    transitionPropPrefix,
    eventType, fnCallbackS,
    prop2val = slson.props,
    when = slson.when,
    transition = slson.transition,
    i, len;

    initAttrsObj( "", slson.props, attr2val );


    for ( transitionProp in transition ) {
      transitionDirective = transition[ transitionProp ];
      transitionPropPrefix =  "transition." + transitionProp + ".";
      if ( transitionDirective.type !== undefined ) {
        attr2val[ transitionPropPrefix + "type" ] =
          transitionDirective.type;
      }
      if ( transitionDirective.duration !== undefined ) {
        attr2val[ transitionPropPrefix + "duration" ] =
          transitionDirective.duration;
      }
      if ( transitionDirective.delay !== undefined ) {
        attr2val[ transitionPropPrefix + "delay" ] =
          transitionDirective.delay;
      }
      if ( transitionDirective.done !== undefined ) {
        attr2val[ transitionPropPrefix + "done" ] =
          transitionDirective.done;
      }
      if ( transitionDirective.args !== undefined ) {
        initAttrsObj( transitionPropPrefix + "args.",
          transitionDirective.args, attr2val );
      }
    }

    for ( eventType in when ) {
      fnCallbackS = when[ eventType ];
      initAttrsArray(  "when." + eventType, fnCallbackS, attr2val );
    }

    if ( slson.$$num !== undefined ) {
      initAttrsObj( "$$num.", slson.$$num, attr2val );
    }

    if ( slson.$$max !== undefined ) {
      initAttrsObj(  "$$max.", slson.$$max, attr2val );
    }



  }

  LAID.Level.prototype.$initAllAttrs = function () {

    var
      observableEventReadonlyS = this.$lson.observe,
      observableEventReadonly, i, len;

    if ( this.isPart ) {
      //this.$initNecessaryAttrs();
    }

   

    if ( observableEventReadonlyS !== undefined ) {
      for ( i = 0, len = observableEventReadonlyS.length; i < len; i++ ) {
        observableEventReadonly = observableEventReadonlyS[ i ];
        if ( eventReadonly2defaultVal[ observableEventReadonly ] ===
         undefined ) {
          console.error("LAID Warning: Non Event Read-Only: " +
           observableEventReadonly );
        } else {
          this.$attr2attrVal[ observableEventReadonly ].give(
           LAID.$emptyAttrVal );
        }
      }
    }

    this.$initNonStateProjectedAttrs();
    this.$updateStates();

  };

  LAID.Level.prototype.$initNonStateProjectedAttrs = function () {

    var i, key, val, stateName, state,

    states = this.$lson.states, when = this.$lson.when,
    transition = this.$lson.transition,
    attr2val = {};



    initAttrsObj( "data.", this.$lson.data, attr2val );

    if ( this.$lson.load !== undefined ) {
      attr2val.load = this.$lson.load;
    }

    for ( stateName in states ) {
        state = states[ stateName ];
        attr2val[ stateName + "." + "onlyif" ] = state.onlyif;
        attr2val[ stateName + "." + "install" ] = state.install;
        attr2val[ stateName + "." + "uninstall" ] = state.uninstall;

    }

    this.$commitAttr2Val( attr2val );

  };

  LAID.Level.prototype.$commitAttr2Val = function ( attr2val ) {

    var attr, val, attrVal;
    for ( attr in attr2val ) {
      val = attr2val[ attr ];
      attrVal = this.$attr2attrVal[ attr ];
      if ( ( attrVal === undefined ) ) {
        attrVal = this.$attr2attrVal[ attr ] = new LAID.AttrVal( attr, this );
      }
      attrVal.update( val );

    }
  };

  /*
  * Return true if attr was created as it exists (in lazy form),
  * false otherwise (it is not present at all to be created)
  */
  LAID.Level.prototype.$createLazyAttr = function ( attr ) {
    var
     readonlyDefaultVal = LAID.$getReadonlyAttrDefaultVal( attr ),
     splitAttrLsonComponentS, attrLsonComponentObj, i, len,
     firstAttrLsonComponent;
    if ( readonlyDefaultVal !== undefined ) {

      this.$attr2attrVal[ attr ] = new LAID.AttrVal( attr, this );



      if ( readonlyDefaultVal === null ) {
        switch ( attr ) {
          case "$numberOfChildren":
            this.$attr2attrVal[ attr ].update( this.$childLevelS.length );
              break;
          case "$naturalWidth":


            this.$updateNaturalWidth();
            break;
          case "$naturalHeight":

            this.$updateNaturalHeight();
            break;
        }
      } else {

        this.$attr2attrVal[ attr ].update( readonlyDefaultVal );

      }
    } else {
      if ( attr.indexOf( "." ) === -1 ) {
        return false;
      } else {
        if ( attr.startsWith( "data." ) ) {
          this.$attr2attrVal[ attr ] = new LAID.AttrVal( attr, this );
          this.$attr2attrVal[ attr ].update( undefined );
        } else {
          splitAttrLsonComponentS = attr.split( "." );
          if ( this.$lson.states === undefined ) {
            return false;
          } else {

            firstAttrLsonComponent = splitAttrLsonComponentS[ 0 ];

            // Get down to state level
            if ( firstAttrLsonComponent === "root" ) {
              attrLsonComponentObj = this.$lson;
            } else if ( LAID.$checkIsValidUtils.stateName(
             firstAttrLsonComponent ) ) {
              attrLsonComponentObj = this.$lson.states[ firstAttrLsonComponent ];
            } else {
              return false;
            }
            splitAttrLsonComponentS.shift();

            // rempve the state part of the attr components
            if ( splitAttrLsonComponentS[ 0 ]  === "when" ) {
              splitAttrLsonComponentS[ splitAttrLsonComponentS.length - 1 ] =
                parseInt( splitAttrLsonComponentS[
                  splitAttrLsonComponentS.length -1 ] ) - 1;
            } else if ( splitAttrLsonComponentS[ 0 ]  !== "transition" ) {
              // props
              if ( attrLsonComponentObj.props !== undefined ) {
                attrLsonComponentObj = attrLsonComponentObj.props; 
              } else {
                return false;
              }
            }


            for ( i = 0, len = splitAttrLsonComponentS.length; i < len; i++ ) {
              attrLsonComponentObj =
               attrLsonComponentObj[ splitAttrLsonComponentS[ i ] ];

              if ( attrLsonComponentObj === undefined ) {
                break;
              }
            }
            // Not present within states
            if ( attrLsonComponentObj === undefined ) {
              return false;
            } else {
              this.$attr2attrVal[ attr ] = new LAID.AttrVal( attr, this );
              this.$attr2attrVal[ attr ].update( attrLsonComponentObj );
            }
          }
        }
      }
    }
    return true;
  };

  /*
  * Solve by recalculating each attr within the
  * level which requires recalculation
  * Return 1 if all attributes were solved
  * Return 2 if some attributes were solved
  * Return 3 if no attributes were solved
  */
  LAID.Level.prototype.$solveForRecalculation = function () {

    var i,
      isSolveProgressed,
      isSolveProgressedOnce = false,
      recalculateDirtyAttrValS = this.$recalculateDirtyAttrValS;

    do {
      isSolveProgressed = false;
      for ( i = 0; i < recalculateDirtyAttrValS.length; i++ ) {
        isSolveProgressed = recalculateDirtyAttrValS[ i ].recalculate();
        //console.log( "\trecalculate", this.path, isSolveProgressed,
        //  recalculateDirtyAttrValS[ i ] );
        if ( isSolveProgressed ) {
          isSolveProgressedOnce = true;
          LAID.$arrayUtils.removeAtIndex( recalculateDirtyAttrValS, i );
          i--;
        }
      }

    } while ( ( recalculateDirtyAttrValS.length !== 0 ) && isSolveProgressed );

    return recalculateDirtyAttrValS.length === 0 ? 1 :
     ( isSolveProgressedOnce ? 2 : 3 );

  };

  /*
  Undefine all current attributes which are influencable
  by states: props, transition, when, $$num, $$max
  */
  LAID.Level.prototype.$undefineStateProjectedAttrs = function() {

    var attr;
    for ( attr in this.$attr2attrVal ) {
      if ( this.$attr2attrVal[ attr ].isStateProjectedAttr ) {
        this.$attr2attrVal[ attr ].update( undefined );
      }
    }
  };





  /* Return the attr2value generated
  by the current states */
  LAID.Level.prototype.getStateAttr2val = function () {

    var attr2val = {};

    if ( this.isManyDerived ) {
      // TODO:MANY: get from Many object
    } else {
      var stringHashedStates = this.$stateS.sort().join( "&" );
      if ( this.$stringHashedStates2_cachedAttr2val_[
       stringHashedStates ] === undefined ) {
        convertSLSONtoAttr2Val( this.generateSLSON(), attr2val);
        this.$stringHashedStates2_cachedAttr2val_[ stringHashedStates ] =
         attr2val;
      }
      return this.$stringHashedStates2_cachedAttr2val_[ stringHashedStates ];
    }

  };


  /*
  *  From the current states generate the
  *  correspinding SLSON (state projected lson)
  *  Requirement: the order of states must be sorted
  */
  LAID.Level.prototype.generateSLSON =  function () {

    this.$stateS.sort();

    var slson = {}, attr2val;

    LAID.$inherit( slson, this.$lson, true, true );

    for ( var i = 0, len = this.$stateS.length; i < len; i++ ) {
      LAID.$inherit( slson, this.$lson.states[ this.$stateS[ i ] ], true, true );
    }

    return slson;

  };




  LAID.Level.prototype.$updateStates = function () {

    this.$undefineStateProjectedAttrs();
    this.$commitAttr2Val( this.getStateAttr2val() );

    //console.log("NEW STATE", this.path, this.$stateS );

  };


  LAID.Level.prototype.attr = function ( attr ) {

    if ( this.$attr2attrVal[ attr ] ) {
      return this.$attr2attrVal[ attr ].calcVal;

    } else if ( ( attr[ 0 ] !== "$" ) &&
        this.$createLazyAttr( attr ) ) {
        LAID.$solveForRecalculation();
      return this.$attr2attrVal[ attr ].calcVal;

    } else {
      return undefined
    }
  };

  LAID.Level.prototype.data = function ( dataKey, value ) {
    this.$changeAttrVal( "data." + dataKey, value );
  };


  LAID.Level.prototype.$getAttrVal = function ( attr ) {
    return this.$attr2attrVal[ attr ];
  };

  /* Manually change attr value */
  LAID.Level.prototype.$changeAttrVal = function ( attr, val ) {
    this.$attr2attrVal[ attr ].update( val, false );
    if ( !LAID.$isRendering ) {
      LAID.$solveForRecalculation();
    } else {
      LAID.$isRecalculateRequiredOnRenderFinish = true;
    }
  };

  LAID.Level.prototype.$addRecalculateDirtyAttrVal = function ( attrVal ) {

    LAID.$arrayUtils.pushUnique( this.$recalculateDirtyAttrValS, attrVal );
    LAID.$arrayUtils.pushUnique( LAID.$recalculateDirtyLevelS, this );

  };

  LAID.Level.prototype.$addNormalRenderDirtyAttrVal = function ( attrVal ) {

    LAID.$arrayUtils.remove( this.$travelRenderDirtyAttrValS, attrVal );
    LAID.$arrayUtils.pushUnique( this.$normalRenderDirtyAttrValS, attrVal );
    LAID.$arrayUtils.pushUnique( LAID.$renderDirtyLevelS, this );

  };

  LAID.Level.prototype.$addTravelRenderDirtyAttrVal = function ( attrVal ) {

    LAID.$arrayUtils.remove( this.$normalRenderDirtyAttrValS, attrVal );
    LAID.$arrayUtils.pushUnique( this.$travelRenderDirtyAttrValS, attrVal );
    LAID.$arrayUtils.pushUnique( LAID.$renderDirtyLevelS, this );

  };



  LAID.Level.prototype.dataTravelBegin = function ( dataKey, finalVal ) {
    var attrVal;
    if ( LAID.$isDataTravelling ) {
      throw ("LAID Error: Existence of another unfinished data travel");
    } else {
      attrVal = this.$attr2attrVal[ "data." + dataKey ];
      if ( attrVal === undefined ) {
        throw ("LAID Error: Inexistence of data key for data travel");
      }
      LAID.isDataTravelling = true;
      LAID.dataTravellingDelta = 0.0;
      LAID.dataTravellingLevel = this;
      LAID.dataTravellingAttrInitialVal = attrVal.val;
      LAID.$dataTravellingAttrVal = attrVal;

      LAID.$isDataTravellingShock = true;
      attrVal.update( finalVal );
      LAID.$solveForRecalculation();
      LAID.$isDataTravellingShock = false;

    }
  };

  LAID.Level.prototype.dataTravelContinue = function ( delta ) {
    if ( !LAID.isDataTravelling ) {
      throw( "LAID Error: Inexistence of a data travel" );
    } else if ( this !== LAID.dataTravellingLevel ){
      throw( "LAID Error: Inexistence of a data travel for this Level" );
    } else {
      if ( LAID.dataTravellingDelta !== delta ) {
        LAID.dataTravellingDelta = delta;
        LAID.$render();
      }
    }
  };

  LAID.Level.prototype.dataTravelArrive = function ( isArrived ) {
    if ( LAID.$isDataTravelling ) {
      throw( "LAID Error: Inexistence of a data travel" );
    } else {

      LAID.isDataTravelling = false;
      LAID.dataTravellingLevel = undefined;

      // clear out attrvalues which are data travelling
      LAID.$clearDataTravellingAttrVals();
      if ( !isArrived ) {
        LAID.$dataTravellingAttrVal.update(
          LAID.dataTravellingAttrInitialVal );
        LAID.$solveForRecalculation();

      } else {

      }


      LAID.$render();
    }
  };


  /*
  * Additional constraint of not being dependent upon
  * parent for the attr
  */
  LAID.Level.prototype.$findChildWithMaxOfAttr =
   function ( attr, attrValIndependentOf, attrChildIndepedentOf ) {
    var
      i, len, curMaxVal, curMaxLevel,
       childLevelS = this.$childLevelS,
       childLevel, childLevelAttrVal,
       attrValChildIndepedentOf;
    for ( i = 0, len = childLevelS.length; i < len; i++ ) {
      childLevel = childLevelS[ i ];
      childLevelAttrVal = childLevel.$attr2attrVal[ attr ];
      attrValChildIndepedentOf =
        childLevel.$attr2attrVal[ attrChildIndepedentOf ];

      if (
          ( childLevelAttrVal !== undefined ) &&
          ( childLevelAttrVal.calcVal || (childLevelAttrVal.calcVal === 0 ) ) &&
          (  ( !attrValChildIndepedentOf ) ||
            ( !attrValChildIndepedentOf.checkIsDependentOnAttrVal(
               attrValIndependentOf )  ) ) ) {

        if ( curMaxLevel === undefined ) {
          curMaxLevel = childLevel;
          curMaxVal = childLevelAttrVal.calcVal;
        } else if ( childLevelAttrVal.calcVal > curMaxVal ) {
          curMaxLevel = childLevel;
        }
      }
    }
    return curMaxLevel;
  };


  LAID.Level.prototype.$updateNaturalWidth = function () {
    if ( this.path === "/" ) {
      this.$attr2attrVal.$naturalWidth.update( window.innerWidth );

    } else if ( this.$lson.type === "text" ) {
      this.$updateNaturalWidthFromText();
    } else {
      this.$naturalWidthLevel = this.$findChildWithMaxOfAttr( "right",
      this.$attr2attrVal.$naturalWidth, "width" );
      this.$attr2attrVal.$naturalWidth.update(
          this.$naturalWidthLevel ?
         ( this.$naturalWidthLevel.$attr2attrVal.right.calcVal || 0 ) :
         0
      );
    }
  };

  LAID.Level.prototype.$updateNaturalHeight = function () {
    if ( this.path === "/" ) {
      this.$attr2attrVal.$naturalHeight.update( window.innerHeight );
    } else if ( this.$lson.type === "text" ) {
      this.$updateNaturalHeightFromText();
    } else {
      this.$naturalHeightLevel = this.$findChildWithMaxOfAttr( "bottom",
      this.$attr2attrVal.$naturalHeight, "height");

      this.$attr2attrVal.$naturalHeight.update(
          this.$naturalHeightLevel ?
         ( this.$naturalHeightLevel.$attr2attrVal.bottom.calcVal || 0 ) :
         0
      );
    }
  };

/*
  LAID.Level.prototype.$kickBackScrollX = function () {
    if ( this.$attr2attrVal.scrollX !== undefined ) {
      this.$addNormalRenderDirtyAttrVal( this.$attr2attrVal.scrollX, true );
    }
  };

  LAID.Level.prototype.$kickBackScrollY = function () {
    if ( this.$attr2attrVal.scrollY !== undefined ) {
      this.$addNormalRenderDirtyAttrVal( this.$attr2attrVal.scrollY, true );
    }
  };
*/

  LAID.Level.prototype.$updateNaturalWidthFromChild = function ( childLevel ) {

    if ( this.$attr2attrVal.$naturalWidth &&
      ( this.path !== "/" ) &&
      ! LAID.$checkIsValidUtils.nan( childLevel.$attr2attrVal.right.calcVal ) &&
      ! childLevel.$attr2attrVal.width.checkIsDependentOnAttrVal(
        this.$attr2attrVal.$naturalWidth)
      ) {

      if ( this.$naturalWidthLevel === undefined ) {
        this.$naturalWidthLevel = childLevel;
      } else if ( this.$naturalWidthLevel === childLevel ) {

        // Check If the current child level responsible for the stretch
        // of the naturalWidth boundary, has receeded
        // If this would be the case, then there is
        // a possibility that it has receded behind another
        // child element which has a higher right position
        // than the current child level responsible for the natural width
        if ( this.$attr2attrVal.$naturalWidth.calcVal >
           childLevel.$attr2attrVal.right.calcVal  ) {
          // Find the child with the next largest right
          // This could be the same child level
          this.$naturalWidthLevel = this.$findChildWithMaxOfAttr( "right",
          this.$attr2attrVal.$naturalWidth, "width");
        }
      } else {
        if ( childLevel.$attr2attrVal.right.calcVal >
          this.$naturalWidthLevel.$attr2attrVal.right.calcVal ) {
            this.$naturalWidthLevel = childLevel;
        }
      }
      this.$attr2attrVal.$naturalWidth.update(
        this.$naturalWidthLevel ?
        ( this.$naturalWidthLevel.$attr2attrVal.right.calcVal || 0 ) :
        0
      );

    }
  };


  LAID.Level.prototype.$updateNaturalHeightFromChild = function ( childLevel ) {


    if ( this.$attr2attrVal.$naturalHeight &&
        ( this.path !== "/" ) &&
       !LAID.$checkIsValidUtils.nan( childLevel.$attr2attrVal.bottom.calcVal ) &&
       !( childLevel.$attr2attrVal.height.checkIsDependentOnAttrVal(
         this.$attr2attrVal.$naturalHeight) )
       ) {

      if ( this.$naturalHeightLevel === undefined ) {
        this.$naturalHeightLevel = childLevel;
      } else if ( this.$naturalHeightLevel === childLevel ) {
        // Check If the current child level responsible for the stretch
          // of the naturalHeight boundary, has receeded
          // If this would be the case, then there is
          // a possibility that it has receded behind another
          // child element which has a higher bottom position
          // than the current child level responsible for the natural height
         if ( this.$attr2attrVal.$naturalHeight.calcVal >
           childLevel.$attr2attrVal.bottom.calcVal  ) {
          // Find the child with the next largest bottom
          // This could be the same child level
          this.$naturalHeightLevel = this.$findChildWithMaxOfAttr( "bottom",
          this.$attr2attrVal.$naturalHeight, "height");
        }
      } else {
        if ( childLevel.$attr2attrVal.bottom.calcVal >
          this.$naturalHeightLevel.$attr2attrVal.bottom.calcVal ) {
            this.$naturalHeightLevel = childLevel;
          }
        }


      this.$attr2attrVal.$naturalHeight.update(
          this.$naturalHeightLevel ?
          ( this.$naturalHeightLevel.$attr2attrVal.bottom.calcVal || 0 ) :
          0
      );
    }
  };

  LAID.Level.prototype.$updateNaturalWidthFromText = function () {

    if ( this.$attr2attrVal.$naturalWidth ) {

        this.part.$naturalWidthTextMode = true;
        this.$addNormalRenderDirtyAttrVal( this.$attr2attrVal.text );

        if ( this.$attr2attrVal.scrollX !== undefined ) {
          this.$addNormalRenderDirtyAttrVal( this.$attr2attrVal.scrollX );
        }
        // temporarily (for current recalculate) cycle
        // set the value to 0. This is only
        // as a render cycle is required for learning
        // the natural width
        this.$attr2attrVal.$naturalWidth.update( 0 );

    }
  };

  LAID.Level.prototype.$updateNaturalHeightFromText = function () {
    if ( this.$attr2attrVal.$naturalHeight) {
      this.part.$naturalHeightTextMode = true;
      this.$addNormalRenderDirtyAttrVal( this.$attr2attrVal.text );

      if ( this.$attr2attrVal.scrollY !== undefined ) {
        this.$addNormalRenderDirtyAttrVal( this.$attr2attrVal.scrollY );
      }
      // temporarily (for current recalculate) cycle
      // set the value to 0. This is only
      // as a render cycle is required for learning
      // the natural height
      this.$attr2attrVal.$naturalHeight.update( 0 );

    }
  };

  LAID.Level.prototype.$updateWhenEventType = function ( eventType ) {

    var
      numFnHandlersForEventType =
        this.$attr2attrVal[ "$$num.when." + eventType ].val,
      fnMainHandler,
      thisLevel = this;

    if ( this.$whenEventType2fnMainHandler[ eventType ] !== undefined ) {
      LAID.$eventUtils.remove( 
        this.part.node, eventType,
          this.$whenEventType2fnMainHandler[ eventType ] );
    }

    if ( numFnHandlersForEventType !== 0 ) {

      fnMainHandler = function ( e ) {
        var i, len, attrValForFnHandler;
        for ( i = 0; i < numFnHandlersForEventType; i++ ) {
          attrValForFnHandler =
          thisLevel.$attr2attrVal[ "when." + eventType + "." + ( i + 1 ) ];
          if ( attrValForFnHandler !== undefined ) {
            attrValForFnHandler.calcVal.call( thisLevel, e );
          }
        }
      };
      LAID.$eventUtils.add( this.part.node, eventType, fnMainHandler );
      this.$whenEventType2fnMainHandler[ eventType ] = fnMainHandler;

    } else {
      this.$whenEventType2fnMainHandler[ eventType ] = undefined;

    }
  };

  LAID.Level.prototype.$checkIsPropInTransition = function ( prop ) {
    return ( this.$attr2attrVal[ "transition." + prop  + ".type" ] !==
      undefined )  ||
      ( this.$attr2attrVal[ "transition." + prop  + ".delay" ] !==
        undefined );
  };

  LAID.Level.prototype.$updateTransitionProp = function ( transitionProp ) {

    if ( this.$isInitiallyRendered ) {

      var
        attr2attrVal = this.$attr2attrVal,
        attr, attrVal,
        transitionPrefix,
        transitionType, transitionDuration, transitionDelay, transitionDone,
        transitionArgS, transitionArg2val = {},
        transitionObj,
        i, len,
        allAffectedProp, // (eg: when `top` changes but transition
        //is provided by `positional`)
        affectedPropAttrVal;

      // TODO: change the below to a helper function
      if ( ( [ "centerX", "right", "centerY", "bottom" ] ).indexOf(
         transitionProp ) !== -1  ) {
        return;
      }

      if ( !this.$checkIsPropInTransition( transitionProp ) ) {
        if ( this.$checkIsPropInTransition( "all" ) ) {
          allAffectedProp = transitionProp;
          transitionProp = "all";
        } else {
          return;
        }
      }


      transitionPrefix = "transition." + transitionProp + ".";

      transitionType =
        attr2attrVal[ transitionPrefix + "type" ] ?
        attr2attrVal[ transitionPrefix + "type" ].calcVal :
        "linear";

      transitionDuration =
        ( attr2attrVal[ transitionPrefix + "duration" ] ?
        attr2attrVal[ transitionPrefix + "duration" ].calcVal :
        0 );
      transitionDelay =
        ( attr2attrVal[ transitionPrefix + "delay" ] ?
        attr2attrVal[ transitionPrefix + "delay" ].calcVal :
        0 );
      transitionDone =
        ( attr2attrVal[ transitionPrefix + "done" ] ?
        attr2attrVal[ transitionPrefix + "done" ].calcVal :
        undefined );
      transitionArgS = LAID.$transitionType2args[ transitionType ] ?
        LAID.$transitionType2args[ transitionType ] : [];


      for ( i = 0, len = transitionArgS.length; i < len; i++ ) {

        transitionArg2val[ transitionArgS[ i ] ] = (
           attr2attrVal[ transitionPrefix + "args." +
            transitionArgS[ i ] ] ?
           attr2attrVal[ transitionPrefix + "args." +
            transitionArgS[ i ] ].calcVal : undefined );
      }

      if ( !allAffectedProp && ( transitionProp === "all" ) ) {

        for ( attr in attr2attrVal ) {
          attrVal = attr2attrVal[ attr ];
          // Only invoke a transition if:
          // (1) The prop is renderable (i.e has a render call)
          // (2) The prop doesn't have a transition of its
          //     own. For instance if "left" already has
          //     a transition then we will not want to override
          //     its transition with the lower priority "all" transition
          if ( attrVal.renderCall &&
              !this.$checkIsPropInTransition( attrVal.attr ) ) {
            this.$updateTransitionAttrVal(
              attrVal,
               transitionType, transitionDelay, transitionDuration,
               transitionArg2val, transitionDone
             );

          }
        }
      } else {

        this.$updateTransitionAttrVal(
           attr2attrVal[ allAffectedProp || transitionProp ],
           transitionType, transitionDelay, transitionDuration,
           transitionArg2val, transitionDone
         );

      }
    }
  };

  LAID.Level.prototype.$updateTransitionAttrVal = function ( attrVal,
    transitionType, transitionDelay, transitionDuration,
    transitionArg2val, transitionDone  ) {

    // First check if the transition information is complete
    if (
          transitionType &&
        ( transitionDuration !== undefined ) &&
        ( transitionDelay !== undefined ) &&
        ( attrVal !== undefined ) &&
        ( attrVal.isTransitionable )
        ) {


      attrVal.startCalcVal =  attrVal.transitionCalcVal;

      attrVal.transition = new LAID.Transition (
          transitionType,
          transitionDelay ,
          transitionDuration, transitionArg2val,
          transitionDone );
    } else if ( attrVal !== undefined ) { // else delete the transition

      attrVal.transition = undefined;
    }
  }








})();
